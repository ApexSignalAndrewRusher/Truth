// vacd5/src/lib.rs
// VACD-5.0 â€” Bare Metal Immortal
// Compile: cargo build --target wasm32-unknown-unknown --release

#![no_std]
extern crate alloc;

use alloc::collections::VecDeque;
use alloc::vec::Vec;
use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub struct Fixed(i32); // Q16.16 - Standard range: -32768 to +32767 (suitable for urban/drone ranges <32km)

impl Fixed {
    pub const fn from_i32(x: i32) -> Self { Fixed(x << 16) }

    pub fn from_scaled_u64(numerator: u64, denominator: u64) -> Self {
        if denominator == 0 { return Fixed(i32::MAX); }
        let scaled = (numerator as u128 * 65536) / (denominator as u128);
        Fixed(if scaled > i32::MAX as u128 { i32::MAX } else { scaled as i32 })
    }

    pub const fn add(self, b: Self) -> Self {
        let result = self.0 as i64 + b.0 as i64;
        let clamped = if result > i32::MAX as i64 {
            i32::MAX
        } else if result < i32::MIN as i64 {
            i32::MIN
        } else {
            result as i32
        };
        Fixed(clamped)
    }

    pub const fn sub(self, b: Self) -> Self {
        let result = self.0 as i64 - b.0 as i64;
        let clamped = if result > i32::MAX as i64 {
            i32::MAX
        } else if result < i32::MIN as i64 {
            i32::MIN
        } else {
            result as i32
        };
        Fixed(clamped)
    }

    pub const fn mul(self, b: Self) -> Self {
        let product = (self.0 as i64 * b.0 as i64) >> 16;
        let clamped = if product > i32::MAX as i64 {
            i32::MAX
        } else if product < i32::MIN as i64 {
            i32::MIN
        } else {
            product as i32
        };
        Fixed(clamped)
    }

    pub const fn div(self, b: Self) -> Self {
        if b.0 == 0 { return Fixed(i32::MAX); }
        let product = (self.0 as i64 << 16) / b.0 as i64;
        let clamped = if product > i32::MAX as i64 {
            i32::MAX
        } else if product < i32::MIN as i64 {
            i32::MIN
        } else {
            product as i32
        };
        Fixed(clamped)
    }

    pub const fn neg(self) -> Self { Fixed(-self.0) }
    pub const fn abs(self) -> Self { Fixed(self.0.abs()) }

    pub fn sqrt(self) -> Self {
        if self.0 <= 0 { return Fixed(0); }
        let mut low = Fixed(0);
        let mut high = if self.0 > (1 << 24) {
            Fixed(self.0 >> 8)
        } else {
            self.add(Fixed::from_i32(1))
        };
        for _ in 0..16 {
            let mid = low.add(high.sub(low).mul(Fixed::from_i32(1).div(Fixed::from_i32(2))));
            if mid.mul(mid).0 <= self.0 {
                low = mid;
            } else {
                high = mid;
            }
        }
        low
    }

    pub const fn min(self, other: Self) -> Self { if self.0 < other.0 { self } else { other } }
    pub const fn max(self, other: Self) -> Self { if self.0 > other.0 { self } else { other } }

    #[cfg(feature = "std")]
    pub fn to_f32(self) -> f32 { 
        self.0 as f32 / 65536.0 
    }
}

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub struct FixedLong(i64); // Q32.32 - Extended range: -2^31 to +2^31 (suitable for aerospace ranges >32km)

impl FixedLong {
    pub const fn from_i64(x: i64) -> Self { FixedLong(x << 32) }

    pub fn from_scaled_u128(numerator: u128, denominator: u128) -> Self {
        if denominator == 0 { return FixedLong(i64::MAX); }
        let scaled = (numerator * 4294967296u128) / denominator;
        FixedLong(if scaled > i64::MAX as u128 { i64::MAX } else { scaled as i64 })
    }

    pub const fn from_fixed(f: Fixed) -> Self {
        FixedLong((f.0 as i64) << 16)
    }

    pub const fn to_fixed(self) -> Fixed {
        let clamped = if self.0 > i32::MAX as i64 {
            i32::MAX
        } else if self.0 < i32::MIN as i64 {
            i32::MIN
        } else {
            self.0 as i32
        };
        Fixed(clamped >> 16)
    }

    pub const fn add(self, b: Self) -> Self {
        let result = self.0 as i128 + b.0 as i128;
        let clamped = if result > i64::MAX as i128 {
            i64::MAX
        } else if result < i64::MIN as i128 {
            i64::MIN
        } else {
            result as i64
        };
        FixedLong(clamped)
    }

    pub const fn sub(self, b: Self) -> Self {
        let result = self.0 as i128 - b.0 as i128;
        let clamped = if result > i64::MAX as i128 {
            i64::MAX
        } else if result < i64::MIN as i128 {
            i64::MIN
        } else {
            result as i64
        };
        FixedLong(clamped)
    }

    pub const fn mul(self, b: Self) -> Self {
        let product = (self.0 as i128 * b.0 as i128) >> 32;
        let clamped = if product > i64::MAX as i128 {
            i64::MAX
        } else if product < i64::MIN as i128 {
            i64::MIN
        } else {
            product as i64
        };
        FixedLong(clamped)
    }

    pub const fn div(self, b: Self) -> Self {
        if b.0 == 0 { return FixedLong(i64::MAX); }
        let product = (self.0 as i128 << 32) / b.0 as i128;
        let clamped = if product > i64::MAX as i128 {
            i64::MAX
        } else if product < i64::MIN as i128 {
            i64::MIN
        } else {
            product as i64
        };
        FixedLong(clamped)
    }

    pub const fn neg(self) -> Self { FixedLong(-self.0) }
    pub const fn abs(self) -> Self { FixedLong(self.0.abs()) }

    pub fn sqrt(self) -> Self {
        if self.0 <= 0 { return FixedLong(0); }
        let mut low = FixedLong(0);
        let mut high = if self.0 > (1i64 << 48) {
            FixedLong(self.0 >> 16)
        } else {
            self.add(FixedLong::from_i64(1))
        };
        for _ in 0..32 {
            let mid = low.add(high.sub(low).mul(FixedLong::from_i64(1).div(FixedLong::from_i64(2))));
            if mid.mul(mid).0 <= self.0 {
                low = mid;
            } else {
                high = mid;
            }
        }
        low
    }

    pub const fn min(self, other: Self) -> Self { if self.0 < other.0 { self } else { other } }
    pub const fn max(self, other: Self) -> Self { if self.0 > other.0 { self } else { other } }

    #[cfg(feature = "std")]
    pub fn to_f64(self) -> f64 { 
        self.0 as f64 / 4294967296.0 
    }
}

pub struct AuditEntry {
    pub index: u64,
    pub prev_hash: [u8; 32],
    pub hash: [u8; 32],
    pub psi: FixedLong,
    pub psi_truth: FixedLong,
    pub violated: bool,
}

pub struct VACD5 {
    chain: VecDeque<AuditEntry>,
    critical_archive: VecDeque<AuditEntry>, // Bounded critical archive
    max_entries: usize,
    max_critical: usize,
    prev_hash: [u8; 32],
}

/// WARNING: Ring buffer behavior
/// When max_entries is reached, oldest entries are discarded from chain.
/// Critical violations are stored in bounded critical_archive (max_critical entries).
/// For unlimited forensics, export critical_archive to persistent storage.
/// System will emit "archive_full" when critical_archive is full.
impl VACD5 {
    pub fn new(max_entries: usize, max_critical: usize) -> Self {
        VACD5 {
            chain: VecDeque::with_capacity(max_entries),
            critical_archive: VecDeque::with_capacity(max_critical),
            max_entries,
            max_critical,
            prev_hash: [0; 32],
        }
    }

    fn sha256(data: &[u8]) -> [u8; 32] {
        const K: [u32; 64] = [
            0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
            0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
            0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
            0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
            0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
            0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
            0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
            0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
        ];

        let mut h: [u32; 8] = [
            0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
        ];

        let msg_len_bits = (data.len() as u64) * 8;
        let mut padded = Vec::new();
        padded.extend_from_slice(data);
        padded.push(0x80);
        while (padded.len() % 64) != 56 {
            padded.push(0);
        }
        padded.extend_from_slice(&msg_len_bits.to_be_bytes());

        for chunk in padded.chunks_exact(64) {
            let mut w = [0u32; 64];
            for i in 0..16 {
                w[i] = u32::from_be_bytes([chunk[4*i], chunk[4*i+1], chunk[4*i+2], chunk[4*i+3]]);
            }
            for i in 16..64 {
                let s0 = w[i-15].rotate_right(7) ^ w[i-15].rotate_right(18) ^ (w[i-15] >> 3);
                let s1 = w[i-2].rotate_right(17) ^ w[i-2].rotate_right(19) ^ (w[i-2] >> 10);
                w[i] = w[i-16].wrapping_add(s0).wrapping_add(w[i-7]).wrapping_add(s1);
            }

            let mut a = h[0];
            let mut b = h[1];
            let mut c = h[2];
            let mut d = h[3];
            let mut e = h[4];
            let mut f = h[5];
            let mut g = h[6];
            let mut hh = h[7];

            for i in 0..64 {
                let s1 = e.rotate_right(6) ^ e.rotate_right(11) ^ e.rotate_right(25);
                let ch = (e & f) ^ ((!e) & g);
                let temp1 = hh.wrapping_add(s1).wrapping_add(ch).wrapping_add(K[i]).wrapping_add(w[i]);
                let s0 = a.rotate_right(2) ^ a.rotate_right(13) ^ a.rotate_right(22);
                let maj = (a & b) ^ (a & c) ^ (b & c);
                let temp2 = s0.wrapping_add(maj);

                hh = g;
                g = f;
                f = e;
                e = d.wrapping_add(temp1);
                d = c;
                c = b;
                b = a;
                a = temp1.wrapping_add(temp2);
            }

            h[0] = h[0].wrapping_add(a);
            h[1] = h[1].wrapping_add(b);
            h[2] = h[2].wrapping_add(c);
            h[3] = h[3].wrapping_add(d);
            h[4] = h[4].wrapping_add(e);
            h[5] = h[5].wrapping_add(f);
            h[6] = h[6].wrapping_add(g);
            h[7] = h[7].wrapping_add(hh);
        }

        let mut result = [0u8; 32];
        for i in 0..8 {
            result[4*i..4*i+4].copy_from_slice(&h[i].to_be_bytes());
        }
        result
    }

    /// Tiers follow VCH v3.12 evidence hierarchy:
    /// 1: Anecdotal / weak       -> max 0.15
    /// 2: Observational          -> max 0.49
    /// 3: Standard sensor        -> max 0.74
    /// 4: High-quality / fused   -> max 0.89
    /// 5: Immutable / multiple   -> max 1.00
    pub fn emit(&mut self, psi: FixedLong, logic: FixedLong, evidence: FixedLong, tier: u8, msg: &str) -> bool {
        let tier_max = match tier {
            1 => FixedLong(6442450944i64),   // 0.15 * 2^32
            2 => FixedLong(21045339750i64), // 0.49 * 2^32
            3 => FixedLong(31782757990i64), // 0.74 * 2^32
            4 => FixedLong(38112935936i64), // 0.89 * 2^32
            5 => FixedLong(4294967296i64 * 1), // 1.00 * 2^32
            _ => FixedLong(4294967296i64 * 1),
        };
        let evidence_capped = evidence.min(tier_max);
        let truth = logic.min(evidence_capped);
        let violated = psi.0 > truth.0;

        let mut data = Vec::new();
        data.extend_from_slice(&(self.chain.len() as u64).to_le_bytes());
        data.extend_from_slice(&self.prev_hash);
        data.extend_from_slice(&psi.0.to_le_bytes());
        data.extend_from_slice(&truth.0.to_le_bytes());
        data.extend_from_slice(&tier.to_le_bytes());
        data.extend_from_slice(msg.as_bytes());

        let hash = Self::sha256(&data);

        let entry = AuditEntry {
            index: self.chain.len() as u64,
            prev_hash: self.prev_hash,
            hash,
            psi,
            psi_truth: truth,
            violated,
        };

        if self.chain.len() == self.max_entries {
            self.chain.pop_front();
        }
        self.chain.push_back(entry.clone());

        if violated {
            if self.critical_archive.len() == self.max_critical {
                // Archive full - emit warning (does not overwrite)
                let _ = self.emit(FixedLong::from_i64(1), FixedLong::from_i64(1), FixedLong::from_i64(0), 5, "archive_full");
            } else {
                self.critical_archive.push_back(entry);
            }
        }

        self.prev_hash = hash;
        violated
    }

    pub fn fuse_2oo3(&mut self, readings: &[Fixed], tier: u8) -> Fixed {
        if readings.len() < 3 { return Fixed(0); }
        // Stack-allocated sort for deterministic timing (no heap)
        let mut sorted = [Fixed(0); 5]; // Max 5 readings supported
        let n = readings.len().min(5);
        for i in 0..n {
            sorted[i] = readings[i];
        }
        // Simple selection sort (constant time for small N)
        for i in 0..n {
            let mut min_idx = i;
            for j in (i + 1)..n {
                if sorted[j].0 < sorted[min_idx].0 {
                    min_idx = j;
                }
            }
            sorted.swap(i, min_idx);
        }
        let median = sorted[n / 2];

        let tolerance = Fixed::from_scaled_u64(1, 10); // 0.1 units
        let agree_count = sorted[..n].iter().filter(|&&r| (r.sub(median)).abs().0 <= tolerance.0).count();
        let ok = agree_count >= (n * 2 / 3);
        let evidence = FixedLong::from_fixed(Fixed::from_i32(if ok { 1 } else { 0 }));

        self.emit(FixedLong::from_fixed(Fixed::from_i32(1)), FixedLong::from_fixed(Fixed::from_i32(1)), evidence, tier, "2oo3");
        median
    }

    /// Evidence semantics: 1 = System Healthy/Nominal, 0 = System Failure/Violation
    pub fn collision(&mut self, range: FixedLong, rel_vel: FixedLong, safe_ttc: FixedLong, tier: u8) -> u8 {
        let min_safe_range = FixedLong(2147483648i64); // 0.5 in Q32.32

        if range.0 <= 0 || range.0 <= min_safe_range.0 {
            let evidence = FixedLong::from_fixed(Fixed::from_i32(0));
            self.emit(FixedLong::from_fixed(Fixed::from_i32(1)), FixedLong::from_fixed(Fixed::from_i32(1)), evidence, tier, "collision_imminent");
            return 2; // Evade
        }

        if rel_vel.0 <= 0 {
            let evidence = FixedLong::from_fixed(Fixed::from_i32(1));
            self.emit(FixedLong::from_fixed(Fixed::from_i32(1)), FixedLong::from_fixed(Fixed::from_i32(1)), evidence, tier, "collision_safe");
            return 0;
        }

        let ttc = range.div(rel_vel);
        let action = if ttc.0 < safe_ttc.mul(FixedLong::from_scaled_u128(1, 2)).0 { 2 }
                    else if ttc.0 < safe_ttc.0 { 1 }
                    else { 0 };

        let evidence = FixedLong::from_fixed(Fixed::from_i32(if action == 0 { 1 } else { 0 }));
        let violated = self.emit(FixedLong::from_fixed(Fixed::from_i32(1)), FixedLong::from_fixed(Fixed::from_i32(1)), evidence, tier, "collision");

        if violated {
            return 1; // Forced brake on VCH violation
        }
        action
    }

    pub fn integrate(&mut self, pos: &mut FixedLong, vel: FixedLong, dt: FixedLong, max_dt: FixedLong, max_vel: FixedLong, tier: u8) {
        let dt_ok = dt.abs().0 <= max_dt.0;
        let vel_ok = vel.abs().0 <= max_vel.0;
        let evidence = FixedLong::from_fixed(Fixed::from_i32(if dt_ok && vel_ok { 1 } else { 0 }));

        if dt_ok && vel_ok {
            *pos = pos.add(vel.mul(dt));
        }

        self.emit(FixedLong::from_fixed(Fixed::from_i32(1)), FixedLong::from_fixed(Fixed::from_i32(1)), evidence, tier, "integrate");
    }

    pub fn get_merkle_root(&self) -> [u8; 32] {
        if self.chain.is_empty() { return [0; 32]; }
        let mut layer: Vec<[u8; 32]> = self.chain.iter().map(|e| e.hash).collect();
        while layer.len() > 1 {
            let mut next = Vec::new();
            for chunk in layer.chunks(2) {
                if chunk.len() == 1 {
                    next.push(chunk[0]);
                } else {
                    let mut input = [0u8; 64];
                    input[..32].copy_from_slice(&chunk[0]);
                    input[32..].copy_from_slice(&chunk[1]);
                    next.push(Self::sha256(&input));
                }
            }
            layer = next;
        }
        layer[0]
    }

    pub fn proof_for_index(&self, index: usize) -> Option<Vec<[u8; 32]>> {
        if index >= self.chain.len() { return None; }
        let mut proof = Vec::new();
        let mut layer: Vec<[u8; 32]> = self.chain.iter().map(|e| e.hash).collect();
        let mut idx = index;
        while layer.len() > 1 {
            let sibling_idx = if idx % 2 == 0 { idx + 1 } else { idx - 1 };
            if sibling_idx < layer.len() {
                proof.push(layer[sibling_idx]);
            }
            idx /= 2;
            let mut next = Vec::new();
            for chunk in layer.chunks(2) {
                if chunk.len() == 1 {
                    next.push(chunk[0]);
                } else {
                    let mut input = [0u8; 64];
                    input[..32].copy_from_slice(&chunk[0]);
                    input[32..].copy_from_slice(&chunk[1]);
                    next.push(Self::sha256(&input));
                }
            }
            layer = next;
        }
        Some(proof)
    }

    pub fn verify_proof(leaf_hash: [u8; 32], proof: &[[u8; 32]], root: [u8; 32], mut index: usize) -> bool {
        let mut computed = leaf_hash;
        for &sibling in proof {
            let mut input = [0u8; 64];
            if index % 2 == 0 {
                input[..32].copy_from_slice(&computed);
                input[32..].copy_from_slice(&sibling);
            } else {
                input[..32].copy_from_slice(&sibling);
                input[32..].copy_from_slice(&computed);
            }
            computed = Self::sha256(&input);
            index /= 2;
        }
        computed == root
    }

    pub fn emit_batch(&mut self, entries: &[(FixedLong, FixedLong, FixedLong, u8, &str)]) {
        for &(psi, logic, evidence, tier, msg) in entries {
            self.emit(psi, logic, evidence, tier, msg);
        }
    }

    pub fn stats(&self) -> (usize, usize, Fixed) {
        let violations = self.chain.iter().filter(|e| e.violated).count();
        let violation_rate = Fixed::from_scaled_u64(violations as u64 * 100, self.chain.len() as u64);
        (self.chain.len(), violations, violation_rate)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sha256() {
        let result = VACD5::sha256(b"abc");
        let expected_abc: [u8; 32] = [
            0xba, 0x78, 0x16, 0xbf, 0x8f, 0x01, 0xcf, 0xea,
            0x41, 0x41, 0x40, 0xde, 0x5d, 0xae, 0x22, 0x23,
            0xb0, 0x03, 0x61, 0xa3, 0x96, 0x17, 0x7a, 0x9c,
            0xb4, 0x10, 0xff, 0x61, 0xf2, 0x00, 0x15, 0xad,
        ];
        assert_eq!(result, expected_abc);

        let result_empty = VACD5::sha256(b"");
        let expected_empty: [u8; 32] = [
            0xe3, 0xb0, 0xc4, 0x42, 0x98, 0xfc, 0x1c, 0x14,
            0x9a, 0xfb, 0xf4, 0xc8, 0x99, 0x6f, 0xb9, 0x24,
            0x27, 0xae, 0x41, 0xe4, 0x64, 0x9b, 0x93, 0x4c,
            0xa4, 0x95, 0x99, 0x1b, 0x78, 0x52, 0xb8, 0x55,
        ];
        assert_eq!(result_empty, expected_empty);
    }
}